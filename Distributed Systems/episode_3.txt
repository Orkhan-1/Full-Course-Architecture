/*
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘        EPISODE 3 â€” TIME & EVENT ORDERING IN DISTRIBUTED SYSTEMS        â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Distributed systems run on multiple nodes with independent clocks.
Without a global clock, ordering events consistently is hard but critical.


1. Why Ordering Matters - Real World Examples

Example 1: Chat Application

Timeline WITHOUT proper ordering:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ User A: "Meeting at 3 PM?"                          â”‚
â”‚                                                     â”‚
â”‚ User B: "No, meeting cancelled"   (sent at 2:55 PM) â”‚
â”‚                                                     â”‚
â”‚ User B: "Yes, let's meet"        (sent at 2:50 PM)  â”‚
â”‚                                                     â”‚
â”‚ âŒ FINAL VIEW: "Yes, let's meet" â†’ CONFUSION!        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

With proper ordering (causal):
"Meeting at 3 PM?" â†’ "Yes, let's meet" â†’ "No, cancelled"

Example 2: Collaborative Editing

Two users editing same document:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ User 1 types: "Hello World"                         â”‚
â”‚                                                     â”‚
â”‚ User 2 types: "Hello Awesome World"                 â”‚
â”‚ (inserts "Awesome" between "Hello" and "World")     â”‚
â”‚                                                     â”‚
â”‚ âŒ Without ordering: Could become                   â”‚
â”‚    "Hello World Awesome" â†’ Makes no sense!          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

2) CLOCK SKEW & TIME IN DISTRIBUTED SYSTEMS

Node clocks are not perfectly synchronized:
- **Clock skew:** difference between node clocks.
- **Clock drift:** gradual divergence over time.
- **Network latency:** messages take time to arrive â†’ timestamps are unreliable.

âš ï¸ Problem: If we use physical clocks to order events, inconsistent ordering may occur.

3) The Solution - Logical Clocks

Lamport Clocks (1978, Leslie Lamport)
Key Insight: "Don't use actual time, count events!"

Lamport Rules:

Each process maintains a counter (initially 0)

On local event: counter += 1

On send message: counter += 1, send counter with message

On receive message: counter = max(local_counter, received_counter) + 1

Visual Representation:

Process P1           Process P2           Process P3
    1                    1                    1
    â”‚ (local event)      â”‚                    â”‚
    2                    â”‚                    â”‚
    â”‚                    â”‚                    â”‚
    3 â”€â”€m1[L=3]â”€â”€â”€â”€â”€â”€â”€â–º  â”‚                    â”‚
    â”‚                    â”‚                    â”‚
    4                    â”‚  4 â† m1 arrives    â”‚
    â”‚                    â”‚  (max(1,3)+1=4)    â”‚
    â”‚                    â”‚  5 (local event)   â”‚
    â”‚                    â”‚  6 â”€â”€m2[L=6]â”€â”€â”€â”€â”€â–º â”‚
    â”‚                    â”‚                    â”‚
    5                    â”‚                    â”‚  7 â† m2 arrives
    â”‚                    â”‚                    â”‚  (max(1,6)+1=7)
    6                    â”‚                    â”‚  8 (local event)

Lamport Properties:

âœ… Guarantees: If event A â†’ B (happens-before), then LC(A) < LC(B)
âŒ Limitation: Cannot detect concurrent events (two independent events may have same LC ordering)

**Illustration:**
Node A            Node B
  LC=1               LC=1
   | Event a         |
   |---------------->| Send a with LC=2
                     | LC := max(1,2)+1=3 Event b
  LC=2 Event a done  |

4) VECTOR CLOCKS
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

   ğŸ’¡ Idea: Each node maintains a vector of counters, one per node.

   - VectorClock[i] = number of events known at Node i
   - On local event: increment own entry
   - On message: send vector, merge using max per entry

   **Example:**
   Node A: [2,0,1]  Node B: [1,3,0]

   - After sending/receiving:
     Node A merges â†’ [2,3,1]
     Node B merges â†’ [2,3,1]

   âœ… Advantages:
   - Detects **concurrent events**
   - Can reconstruct partial ordering
   - Crucial for CRDTs, distributed versioning


Example: 3 Processes

Initial:        P1:[0,0,0]  P2:[0,0,0]  P3:[0,0,0]

P1 local event: P1:[1,0,0]
P1 sends to P2: P1:[2,0,0] â†’ m1

P2 receives m1: P2:[2,0,0] â†’ P2 local: [2,1,0]
P2 sends to P3: P2:[2,2,0] â†’ m2

P3 local event: P3:[0,0,1]
P3 receives m2: P3:[max(0,2),max(0,2),max(1,0)+1]
               = [2,2,2]

Now we can detect concurrency!

   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   6ï¸âƒ£ KEY TAKEAWAYS
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

   - Physical clocks alone are unreliable in distributed systems.
   - **Lamport clocks:** simple, maintains â€œhappens-beforeâ€ order.
   - **Vector clocks:** detect concurrency, stronger ordering info.
   - Ordering is essential for correctness (banking, chat, logs).
   - Real-world systems: DynamoDB, Cassandra, Riak, and CRDT-based systems
   rely on vector clocks for conflict resolution.

   */